'use server'

import { openai } from '@/lib/openai';
import { ApiSchema } from '@/types/schema';
import { z } from 'zod';
import { zodResponseFormat } from 'openai/helpers/zod';

const schemaFieldSchema: z.ZodSchema<any> = z.lazy(() => z.object({
  name: z.string(),
  type: z.enum(['string', 'number', 'boolean', 'object', 'array']),
  required: z.boolean(),
  description: z.string().nullable(),
  children: z.array(schemaFieldSchema).nullable(),
  arrayItemType: z.enum(['string', 'number', 'boolean', 'object']).nullable(),
  fakerType: z.string().nullable().describe("The specific Faker.js type to use for data generation (e.g., 'person.firstName', 'internet.email', 'commerce.price'). Choose the most relevant one from standard Faker modules.")
}));

const apiSchemaSchema = z.object({
  name: z.string(),
  description: z.string(),
  endpointSlug: z.string(),
  fields: z.array(schemaFieldSchema)
});

export async function generateSchemaFromPrompt(prompt: string): Promise<Partial<ApiSchema>> {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API Key is missing');
  }

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-5-nano-2025-08-07",
      messages: [
        {
          role: "system",
          content: `You are an expert API architect. Generate a REST API schema based on the user's description.
        
        Rules:
        1. Use proper nesting for objects and arrays.
        2. Choose appropriate field types.
        3. Create a clean, URL-friendly slug.
        4. Select the most appropriate 'fakerType' for string and number fields to ensure realistic mock data.
           Examples: 
           - 'email' -> 'internet.email'
           - 'price' -> 'commerce.price'
           - 'name' -> 'person.fullName'
           - 'city' -> 'location.city'
           - 'company' -> 'company.name'
        `
        },
        { role: "user", content: prompt },
      ],
      response_format: zodResponseFormat(apiSchemaSchema, "api_schema"),
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error('No content generated');
    }

    const parsed = JSON.parse(content);
    console.log('OpenAI Raw Response:', JSON.stringify(parsed, null, 2));
    
    // Helper to clean up null values to undefined
    const cleanSchema = (obj: any): any => {
      if (Array.isArray(obj)) {
        return obj.map(cleanSchema);
      }
      if (obj && typeof obj === 'object') {
        const newObj: any = {};
        for (const key in obj) {
          if (obj[key] !== null) {
            newObj[key] = cleanSchema(obj[key]);
          }
        }
        return newObj;
      }
      return obj;
    };

    const cleanedSchema = cleanSchema(parsed);
    console.log('Cleaned Schema:', JSON.stringify(cleanedSchema, null, 2));

    if (!cleanedSchema || !cleanedSchema.fields) {
      throw new Error('Invalid schema: missing fields');
    }
    
    // Add IDs to fields as they are required by the UI but not generated by AI
    const addIds = (fields: any[]): any[] => {
      if (!Array.isArray(fields)) return [];
      return fields.map(field => ({
        ...field,
        id: crypto.randomUUID(),
        children: field.children ? addIds(field.children) : undefined
      }));
    };

    return {
      ...cleanedSchema,
      fields: addIds(cleanedSchema.fields)
    };

  } catch (error) {
    console.error('OpenAI Schema Generation Error:', error);
    throw new Error('Failed to generate schema from prompt');
  }
}
